#pragma once

/*--------------------------------------------------------------------
  The WS2812B library is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation, either version 3 of
  the License, or (at your option) any later version.
  It is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.
  See <http://www.gnu.org/licenses/>.
  --------------------------------------------------------------------*/

#include <Arduino.h>

#include "array.hpp"
#include "common.hpp"

namespace otto_mcu {

  // New version uses one large LUT as its faster index into sequential bytes for
  // the GRB pattern
  static uint8_t encoderLookup[256 * 3] = {
    0x92, 0x49, 0x24, 0x92, 0x49, 0x26, 0x92, 0x49, 0x34, 0x92, 0x49, 0x36, 0x92, 0x49, 0xA4, 0x92,
    0x49, 0xA6, 0x92, 0x49, 0xB4, 0x92, 0x49, 0xB6, 0x92, 0x4D, 0x24, 0x92, 0x4D, 0x26, 0x92, 0x4D,
    0x34, 0x92, 0x4D, 0x36, 0x92, 0x4D, 0xA4, 0x92, 0x4D, 0xA6, 0x92, 0x4D, 0xB4, 0x92, 0x4D, 0xB6,
    0x92, 0x69, 0x24, 0x92, 0x69, 0x26, 0x92, 0x69, 0x34, 0x92, 0x69, 0x36, 0x92, 0x69, 0xA4, 0x92,
    0x69, 0xA6, 0x92, 0x69, 0xB4, 0x92, 0x69, 0xB6, 0x92, 0x6D, 0x24, 0x92, 0x6D, 0x26, 0x92, 0x6D,
    0x34, 0x92, 0x6D, 0x36, 0x92, 0x6D, 0xA4, 0x92, 0x6D, 0xA6, 0x92, 0x6D, 0xB4, 0x92, 0x6D, 0xB6,
    0x93, 0x49, 0x24, 0x93, 0x49, 0x26, 0x93, 0x49, 0x34, 0x93, 0x49, 0x36, 0x93, 0x49, 0xA4, 0x93,
    0x49, 0xA6, 0x93, 0x49, 0xB4, 0x93, 0x49, 0xB6, 0x93, 0x4D, 0x24, 0x93, 0x4D, 0x26, 0x93, 0x4D,
    0x34, 0x93, 0x4D, 0x36, 0x93, 0x4D, 0xA4, 0x93, 0x4D, 0xA6, 0x93, 0x4D, 0xB4, 0x93, 0x4D, 0xB6,
    0x93, 0x69, 0x24, 0x93, 0x69, 0x26, 0x93, 0x69, 0x34, 0x93, 0x69, 0x36, 0x93, 0x69, 0xA4, 0x93,
    0x69, 0xA6, 0x93, 0x69, 0xB4, 0x93, 0x69, 0xB6, 0x93, 0x6D, 0x24, 0x93, 0x6D, 0x26, 0x93, 0x6D,
    0x34, 0x93, 0x6D, 0x36, 0x93, 0x6D, 0xA4, 0x93, 0x6D, 0xA6, 0x93, 0x6D, 0xB4, 0x93, 0x6D, 0xB6,
    0x9A, 0x49, 0x24, 0x9A, 0x49, 0x26, 0x9A, 0x49, 0x34, 0x9A, 0x49, 0x36, 0x9A, 0x49, 0xA4, 0x9A,
    0x49, 0xA6, 0x9A, 0x49, 0xB4, 0x9A, 0x49, 0xB6, 0x9A, 0x4D, 0x24, 0x9A, 0x4D, 0x26, 0x9A, 0x4D,
    0x34, 0x9A, 0x4D, 0x36, 0x9A, 0x4D, 0xA4, 0x9A, 0x4D, 0xA6, 0x9A, 0x4D, 0xB4, 0x9A, 0x4D, 0xB6,
    0x9A, 0x69, 0x24, 0x9A, 0x69, 0x26, 0x9A, 0x69, 0x34, 0x9A, 0x69, 0x36, 0x9A, 0x69, 0xA4, 0x9A,
    0x69, 0xA6, 0x9A, 0x69, 0xB4, 0x9A, 0x69, 0xB6, 0x9A, 0x6D, 0x24, 0x9A, 0x6D, 0x26, 0x9A, 0x6D,
    0x34, 0x9A, 0x6D, 0x36, 0x9A, 0x6D, 0xA4, 0x9A, 0x6D, 0xA6, 0x9A, 0x6D, 0xB4, 0x9A, 0x6D, 0xB6,
    0x9B, 0x49, 0x24, 0x9B, 0x49, 0x26, 0x9B, 0x49, 0x34, 0x9B, 0x49, 0x36, 0x9B, 0x49, 0xA4, 0x9B,
    0x49, 0xA6, 0x9B, 0x49, 0xB4, 0x9B, 0x49, 0xB6, 0x9B, 0x4D, 0x24, 0x9B, 0x4D, 0x26, 0x9B, 0x4D,
    0x34, 0x9B, 0x4D, 0x36, 0x9B, 0x4D, 0xA4, 0x9B, 0x4D, 0xA6, 0x9B, 0x4D, 0xB4, 0x9B, 0x4D, 0xB6,
    0x9B, 0x69, 0x24, 0x9B, 0x69, 0x26, 0x9B, 0x69, 0x34, 0x9B, 0x69, 0x36, 0x9B, 0x69, 0xA4, 0x9B,
    0x69, 0xA6, 0x9B, 0x69, 0xB4, 0x9B, 0x69, 0xB6, 0x9B, 0x6D, 0x24, 0x9B, 0x6D, 0x26, 0x9B, 0x6D,
    0x34, 0x9B, 0x6D, 0x36, 0x9B, 0x6D, 0xA4, 0x9B, 0x6D, 0xA6, 0x9B, 0x6D, 0xB4, 0x9B, 0x6D, 0xB6,
    0xD2, 0x49, 0x24, 0xD2, 0x49, 0x26, 0xD2, 0x49, 0x34, 0xD2, 0x49, 0x36, 0xD2, 0x49, 0xA4, 0xD2,
    0x49, 0xA6, 0xD2, 0x49, 0xB4, 0xD2, 0x49, 0xB6, 0xD2, 0x4D, 0x24, 0xD2, 0x4D, 0x26, 0xD2, 0x4D,
    0x34, 0xD2, 0x4D, 0x36, 0xD2, 0x4D, 0xA4, 0xD2, 0x4D, 0xA6, 0xD2, 0x4D, 0xB4, 0xD2, 0x4D, 0xB6,
    0xD2, 0x69, 0x24, 0xD2, 0x69, 0x26, 0xD2, 0x69, 0x34, 0xD2, 0x69, 0x36, 0xD2, 0x69, 0xA4, 0xD2,
    0x69, 0xA6, 0xD2, 0x69, 0xB4, 0xD2, 0x69, 0xB6, 0xD2, 0x6D, 0x24, 0xD2, 0x6D, 0x26, 0xD2, 0x6D,
    0x34, 0xD2, 0x6D, 0x36, 0xD2, 0x6D, 0xA4, 0xD2, 0x6D, 0xA6, 0xD2, 0x6D, 0xB4, 0xD2, 0x6D, 0xB6,
    0xD3, 0x49, 0x24, 0xD3, 0x49, 0x26, 0xD3, 0x49, 0x34, 0xD3, 0x49, 0x36, 0xD3, 0x49, 0xA4, 0xD3,
    0x49, 0xA6, 0xD3, 0x49, 0xB4, 0xD3, 0x49, 0xB6, 0xD3, 0x4D, 0x24, 0xD3, 0x4D, 0x26, 0xD3, 0x4D,
    0x34, 0xD3, 0x4D, 0x36, 0xD3, 0x4D, 0xA4, 0xD3, 0x4D, 0xA6, 0xD3, 0x4D, 0xB4, 0xD3, 0x4D, 0xB6,
    0xD3, 0x69, 0x24, 0xD3, 0x69, 0x26, 0xD3, 0x69, 0x34, 0xD3, 0x69, 0x36, 0xD3, 0x69, 0xA4, 0xD3,
    0x69, 0xA6, 0xD3, 0x69, 0xB4, 0xD3, 0x69, 0xB6, 0xD3, 0x6D, 0x24, 0xD3, 0x6D, 0x26, 0xD3, 0x6D,
    0x34, 0xD3, 0x6D, 0x36, 0xD3, 0x6D, 0xA4, 0xD3, 0x6D, 0xA6, 0xD3, 0x6D, 0xB4, 0xD3, 0x6D, 0xB6,
    0xDA, 0x49, 0x24, 0xDA, 0x49, 0x26, 0xDA, 0x49, 0x34, 0xDA, 0x49, 0x36, 0xDA, 0x49, 0xA4, 0xDA,
    0x49, 0xA6, 0xDA, 0x49, 0xB4, 0xDA, 0x49, 0xB6, 0xDA, 0x4D, 0x24, 0xDA, 0x4D, 0x26, 0xDA, 0x4D,
    0x34, 0xDA, 0x4D, 0x36, 0xDA, 0x4D, 0xA4, 0xDA, 0x4D, 0xA6, 0xDA, 0x4D, 0xB4, 0xDA, 0x4D, 0xB6,
    0xDA, 0x69, 0x24, 0xDA, 0x69, 0x26, 0xDA, 0x69, 0x34, 0xDA, 0x69, 0x36, 0xDA, 0x69, 0xA4, 0xDA,
    0x69, 0xA6, 0xDA, 0x69, 0xB4, 0xDA, 0x69, 0xB6, 0xDA, 0x6D, 0x24, 0xDA, 0x6D, 0x26, 0xDA, 0x6D,
    0x34, 0xDA, 0x6D, 0x36, 0xDA, 0x6D, 0xA4, 0xDA, 0x6D, 0xA6, 0xDA, 0x6D, 0xB4, 0xDA, 0x6D, 0xB6,
    0xDB, 0x49, 0x24, 0xDB, 0x49, 0x26, 0xDB, 0x49, 0x34, 0xDB, 0x49, 0x36, 0xDB, 0x49, 0xA4, 0xDB,
    0x49, 0xA6, 0xDB, 0x49, 0xB4, 0xDB, 0x49, 0xB6, 0xDB, 0x4D, 0x24, 0xDB, 0x4D, 0x26, 0xDB, 0x4D,
    0x34, 0xDB, 0x4D, 0x36, 0xDB, 0x4D, 0xA4, 0xDB, 0x4D, 0xA6, 0xDB, 0x4D, 0xB4, 0xDB, 0x4D, 0xB6,
    0xDB, 0x69, 0x24, 0xDB, 0x69, 0x26, 0xDB, 0x69, 0x34, 0xDB, 0x69, 0x36, 0xDB, 0x69, 0xA4, 0xDB,
    0x69, 0xA6, 0xDB, 0x69, 0xB4, 0xDB, 0x69, 0xB6, 0xDB, 0x6D, 0x24, 0xDB, 0x6D, 0x26, 0xDB, 0x6D,
    0x34, 0xDB, 0x6D, 0x36, 0xDB, 0x6D, 0xA4, 0xDB, 0x6D, 0xA6, 0xDB, 0x6D, 0xB4, 0xDB, 0x6D, 0xB6};

  enum struct LEDGroup : uint8_t { funcs = 0, channels = 1, seq = 2};

  struct LEDId {
    LEDId(LEDGroup group, uint8_t num) : group(group), number(num) {}
    LEDGroup group = LEDGroup::funcs;
    uint8_t number = 0;
    void show();
  };

  struct WS2812B {
    struct Group {
      Group(GPIOPin cs, uint16_t numLEDs);
      ~Group();

      void updateLength(uint16_t n);
      uint16_t numPixels() const;
      void setPixelColor(uint8_t n, uint8_t r, uint8_t g, uint8_t b);
      void show(WS2812B& controler);
      void clear();

      GPIOPin cs_pin;
      uint8_t* pixels = nullptr;
      uint16_t numLEDs = 0;  // Number of RGB LEDs in strip
      uint16_t numBytes = 0; // Size of 'pixels' buffer

      uint8_t* doubleBuffer = nullptr; // Holds the start of the double buffer (1 buffer for async
                                       // DMA transfer and one for the API interaction.
    };

    // Constructor: number of LEDs
    WS2812B(Group g1, Group g2, Group g3); // Constuctor
    ~WS2812B();
    void begin();
    void show();
    void setPixelColor(LEDId, uint8_t r, uint8_t g, uint8_t b);

    //   setPixelColor(uint16_t n, uint8_t r, uint8_t g, uint8_t b, uint8_t w),
    void setPixelColor(LEDId, uint32_t c);
    void setBrightness(uint8_t);
    void clear();
    uint8_t getBrightness() const;
    static uint32_t Color(uint8_t r, uint8_t g, uint8_t b);
    static uint32_t Color(uint8_t r, uint8_t g, uint8_t b, uint8_t w);

    void select(Group& g);

    inline bool canShow()
    {
      return (micros() - endTime) >= 300L;
    }

    Group& group(LEDGroup id) {
      return groups[static_cast<uint8_t>(id)];
    }

  private:
    boolean begun = false; // true if begin() previously called
    uint8_t brightness = 255;
    util::array<Group, 3> groups; // Holds the current LED color values, which the external API
                                     // calls interact with 9 bytes per pixel + start + end empty
                                     // bytes
    uint8_t rOffset;                 // Index of red byte within each 3- or 4-byte pixel
    uint8_t gOffset;                 // Index of green byte
    uint8_t bOffset;                 // Index of blue byte
    uint8_t wOffset;                 // Index of white byte (same as rOffset if no white)
    uint32_t endTime;                // Latch timing reference
  };
} // namespace otto_mcu
